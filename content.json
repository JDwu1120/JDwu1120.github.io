[{"title":"","date":"2017-03-14T02:05:03.000Z","path":"2017/03/14/C:C++编译器中“字节对齐”的工作原理/","text":"title:C/C++编译器中“字节对齐”的工作原理$ 一 .字节对齐的概念 编译器在编译我们写好的c/c++代码时会根据我们设置的“字节对齐”方式来对我们所定义元素进行多种不同方式的储存。在单字节对齐的条件下声明如下代码：char a; short b;我们知道 char 类型默认是1个字节（8个比特），short类型是两个字节（16比特），在一般的操作系统中默认的一个储存单元是2个字节，所以如果在单字节对齐的条件下，上述代码会被储存为如下形式：（下图所示每一行为一个存储单元） 按2字节的对齐方式进行储存则有如下对齐方式：（每一行代表一个存储单元） $ 二 .实验步骤及环境 本人的程序编译环境是mac，所用的编译器是xcode，上网查资料发现xcode没有自带的字节对齐选项，只能通过c/c++自带的代码进行字节对齐。下图给出一个结构体分别在1 2 4 8 16字节下在二进制文件中的存储方式。所使用的二进制文件编辑器的vim，使用方式：在命令行中输入 vim -b 文件路径/test.txt。由于结构体是以二进制的形式存储在文件中所以打开文件后将会出现乱码显示如图： 之后输入命令 :%!xxd,将文件转换成16进制后进行查看。以下是如下代码以不同字节存储在文件中的不同体现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc, const char * argv[]) &#123; //计算机组成原理——字节对齐测试 #pragma pack(1) struct test1 &#123; char x1; short x2; float x3; char x4; &#125;; test1 a; FILE *fp; fp = fopen(\"/Users/wujindong/Downloads/test1.txt\", \"wb\"); fwrite(&amp;a,sizeof(a),1,fp); fclose(fp);#pragma pack(2) struct test2 &#123; char x1; short x2; float x3; char x4; &#125;; test2 b; fp = fopen(\"/Users/wujindong/Downloads/test2.txt\", \"wb\"); fwrite(&amp;b,sizeof(b),1,fp); fclose(fp);#pragma pack(4) struct test4 &#123; char x1; short x2; float x3; char x4; &#125;; test4 c; fp = fopen(\"/Users/wujindong/Downloads/test4.txt\", \"wb\"); fwrite(&amp;c,sizeof(c),1,fp); fclose(fp);#pragma pack(8) struct test8 &#123; char x1; short x2; float x3; char x4; &#125;; test8 d; fp = fopen(\"/Users/wujindong/Downloads/test8.txt\", \"wb\"); fwrite(&amp;d,sizeof(d),1,fp); fclose(fp);#pragma pack(16) struct test16 &#123; char x1; short x2; float x3; char x4; &#125;; test16 e; fp = fopen(\"/Users/wujindong/Downloads/test16.txt\", \"wb\"); fwrite(&amp;e,sizeof(e),1,fp); fclose(fp); return 0;&#125; 其产生的文件对应字节如下： 用二进制查看工具结果如下（以下顺序是：1 2 4 8 16字节） 由上述分析及图示可以得知，在1字节存储时，x1与x4被分配到一个储存单元中，x2在一个储存单元中，x3占两个储存单元。在2字节储存中，x1 x4被分配到两个不同的单元中，x2 x3和1字节时一样。 在4字节存储方式时作出如下实验：先删除 char x4 结果 原先12字节的文件变成了8字节， 在删除变量x1发现，文件还是8字节，由此可以的出：原先四个变量为，x1(1字节)，x2(两字节)被存储在一个4字节的存储单元中，x3(4字节)，x4（1字节）被分别存储在一个4字节的存储单元中。同理，8字节和16字节作出如下同样实验得出： 8字节时，删除x1（1字节）文件还是12字节，删除x2（2字节）后文件变为8字节，可知x1和x3被存储在一个4字节空间内。在删除x3（4字节）后 文件变为1字节，说明当只剩下一个变量时，即时选择了字节对齐，编译器也只会保留那个变量当前字节。除此之外只删除变量x3（4字节）会出现如下情景 剩下的x1 x2 x4三个变量只有6字节大小，说明每个变量各自占一个2字节的存储单元。16字时，只删除x1（1字节）出现的情况与8字节相同剩下的文件为8字节，但是删除x3（4字节）后产生的文件为8字节而8进制的时候为6字节 当只剩下一个变量x1时在8字节下产生的文件为1字节，在16字节文件下产生的文件为8字节。 同时在8字节和16字节只剩下x3（4字节时）产生的文件为: $ 三 .c/c++中设置字节对齐的几种方式 1.使用pragma pack的方式选择字节对齐： 123456789#pragma pack(1) //让编译器对这个结构作1字节对齐struct test&#123;char x1;short x2;float x3;char x4;&#125;;#pragma pack() //取消1字节对齐，恢复为默认4字节对齐 2.使用attribute选项 12345678#define GNUC_PACKED __attribute__((packed))struct PACKED test&#123;char x1;short x2;float x3;char x4;&#125;GNUC_PACKED; $ 写在最后 虽然这只是一次小小的计组作业，但是却能让我们深刻的体会到字节对齐的概念，并且深入理解内存的存储方式。 文章为作者原创，转载请注明出处。","tags":[]},{"title":"Laravel blade模版引擎学习","date":"2017-03-13T15:49:25.000Z","path":"2017/03/13/Laravel blade模版学习/","text":"[TOC] ##一 .什么是模版引擎？ 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。 ##二 .模版引擎的三个作用 1.变量值的输出（echo） 2.条件判断和循环（if ... else、for、foreach、while） 3.引入或继承其他文件 ##三 .什么是blade引擎？ Blade是Laravel提供的一个非常简单、强大的模板引擎，不同于其他流行的PHP模板引擎，Blade在视图中并不约束你使用PHP原生代码。所有的Blade视图都会被编译成原生PHP代码并缓存起来直到被修改，这意味着对应用的性能而言Blade基本上是零开销。Blade视图文件使用.blade.php文件扩展并存放在resources/views目录下。 代码示意12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Laravel&lt;/title&gt; &lt;link href=\"https://fonts.googleapis.com/css?family=Lato:100\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; body &#123; margin: 0; padding: 0; width: 100%; display: table; font-weight: 100; font-family: 'Lato'; &#125; .container &#123; text-align: center; display: table-cell; vertical-align: middle; &#125; .content &#123; text-align: center; display: inline-block; &#125; .title &#123; font-size: 96px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"title\"&gt;Laravel 5&lt;/div&gt; &lt;?php echo \"welcome\"; ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这里我们注意到，在上述代码中不仅有html代码还有一句echo \"welcome\"; ?>```这是因为blade引擎默认的文件都是php文件，与普通的html文件不同，我们不仅能在里面写html代码更能编写php代码。除此之外，blade引擎还自带了特殊的关键字：@section、@yield、@extends、@parent等命令。123456789101112131415161718**@section用来标记一个blade模版中的一部分，用@yield让这部分在另一个模版中表示出来。**```html&lt;!-- 存放在 resources/views/layouts/master.blade.php --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;App Name - @yield(&apos;title&apos;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section(&apos;sidebar&apos;) This is the master sidebar. @show &lt;div class=&quot;container&quot;&gt; @yield(&apos;content&apos;) &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; &gt;上述代码表示标记了一个名叫:sidebar的部分用来在之后的地方使用，并且用到了以前标记的 title 和 content这两个部分。 定义子页面的时候，可以使用Blade的@extends指令来指定子页面所继承的布局，继承一个Blade布局的视图将会使用@section指令注入内容到布局的片段中，记住，如上面例子所示，这些片段的内容将会显示在布局中使用@yield的地方： 123456789101112131415&lt;!-- 存放在 resources/views/layouts/child.blade.php --&gt;@extends('layouts.master')@section('title', 'Page Title')@section('sidebar') @parent &lt;p&gt;This is appended to the master sidebar.&lt;/p&gt;@endsection@section('content') &lt;p&gt;This is my body content.&lt;/p&gt;@endsection 使用@parent可以在已经标记好的@section中添加（不是覆盖）新的东西，如上述就在sidebar中加入了一行&lt;p&gt;This is appended to the master sidebar.&lt;/p&gt;代码，并且还会保存之前的东西。 还有其他的相关操作如数据显示、流程控制、服务注入等请参考laravel文档 ##四 模版渲染原理 Laravel 的 View 部分是内置了两套输出系统：直接输出和使用 Blade 引擎“编译”后输出，默认情况下它们通过文件名后缀来选择：.blade.PHP 后缀的认为是模板视图文件，其他的 .php 文件按照 PHP 本身的方式执行。虽然 Blade 模板文件中也可以随意嵌入 PHP 代码，但如果并没有使用，系统还去进行语法解析和替换也是没有必要的，这样可以提高效率。使用 View 组件输出时，不管是调用 helpers 中提供的 view 函数还是使用 Facades 提供静态接口View::make()，实际上执行的都是 Illuminate\\View\\Factory 中的 make 方法。以此为入口，很容易就能知道视图解析输出的流程：查找视图文件；根据文件名后缀从 Container 中取出响应的引擎；加载视图文件或编译后加载编译后的文件执行，同时将需要解析的数据暴露在视图文件环境中。更多详细内容请参考skykingf的博客","tags":[]},{"title":"Hello World","date":"2017-03-13T07:51:01.000Z","path":"2017/03/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]