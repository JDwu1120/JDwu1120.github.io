[{"title":"","date":"2017-03-20T16:09:03.000Z","path":"2017/03/21/python_pachong/","text":"#title: 基于python的简单爬虫架构学习#一: 什么是爬虫 爬虫即网络爬虫，是一种自动获取网页内容的程序。是搜索引擎的重要组成部分，因此搜索引擎优化很大程度上就是针对爬虫而做出的优化。主要分类网络爬虫为搜索引擎从万维网下载网页。一般分为传统爬虫和聚焦爬虫。传统爬虫从一个或若干初始网页的URL开始，获得初始网页上的URL，在抓取网页的过程中，不断从当前页面上抽取新的URL放入队列，直到满足系统的一定停止条件。通俗的讲，也就是通过源码解析来获得想要的内容。聚焦爬虫的工作流程较为复杂，需要根据一定的网页分析算法过滤与主题无关的链接，保留有用的链接并将其放入等待抓取的URL队列。然后，它将根据一定的搜索策略从队列中选择下一步要抓取的网页URL，并重复上述过程，直到达到系统的某一条件时停止。另外，所有被爬虫抓取的网页将会被系统存贮，进行一定的分析、过滤，并建立索引，以便之后的查询和检索；对于聚焦爬虫来说，这一过程所得到的分析结果还可能对以后的抓取过程给出反馈和指导。 #二: 爬虫需要具备基本元素 url管理器、网页下载器、和网页分析器它们之间的关系如下：url管理器将需要爬去的链接传输给网页下载器，网页下载器将网页下载到本地存取成一个文件或者一个字符串，之后交给网页分析器提取出要分析的数据。稍作改造之后得到以下时序图（图片来自慕课网） url管理器，在大型的应用中通常放到cache服务器中，但是如果是个人小型应用，可以直接放到python的set()中。网页下载器，我使用的是python自带的urllib2这个库，基本语法如下： 123456789101112131415161718192021222324#-*- coding: UTF-8 -*-import cookielibimport urllib2url = \"https://www.baidu.com\"print '第一种方法'response1 = urllib2.urlopen(url)print response1.getcode()print len(response1.read())print '第二种方法'request = urllib2.Request(url)request.add_header('user-agent',\"Mozilla/5.0\")response2 = urllib2.urlopen(request)print response2.getcode()print len(response2.read())print '第三种方法'cj =cookielib.CookieJar()opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))urllib2.install_opener(opener)response3 = urllib2.urlopen(url)print response3.getcode()print cjprint response3.read() 首先确定一个要爬取的url，之后使用urllib2.urlopen(url)这个方法去请求这个url，之后response1这个对象就包含了爬取到的网页的所有的信息，使用getcode()方法得到返回码，200表示爬取成功。之后使用read()方法可以得到下载的网页（字符串）。有时对于有些做了特定浏览器访问限制，和一些需要登录的网站进行爬取时，我们还需要对我们爬虫做一下特殊的处理，如urllib2.request(url)这个方法可以得到一个对指定url访问请求的对象，request 代表了这个请求的对象，之后我们可以用add_header()方法添加进去我们需要的东西。说白了就是为我们需要请求的url加上一层装饰来逃脱网页的检测。如果我们需要加入cookie的话，我们还可以引入cookielib这个包，之后我们创建一个开启工具opener，然后为这个opener添加进去cookie，当然还可以添加进去很多其他的东西，之后为我们的urllib2安装这个opener，然后就可以获取到网页的cookie了。 网页分析器，这里我使用的是python的bs4中的beautifulsoup这个包， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#-*- coding: UTF-8 -*-from bs4 import BeautifulSouphtmil_doc = \"\"\"&lt;body&gt;&lt;table width=\"100%\" border=\"0\"&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td align=\"center\"&gt; &lt;strong&gt; &lt;font size=\"5\"&gt;天津大学16172学期 课程表&lt;/font&gt;&lt;/strong&gt;&lt;p&gt; &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table width=\"90%\" border=\"0\" align=\"center\"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span class=\"gensmall\"&gt;教室：44楼A区105&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table width=\"100%\" align=\"center\" bgcolor=\"#cccccc\" cellspacing=\"1\"&gt; &lt;tbody&gt;&lt;tr height=\"40\"&gt; &lt;td&gt;&amp;nbsp; &lt;/td&gt; &lt;td align=\"center\"&gt;&lt;font class=\"whiteTitleSmall\"&gt;周一&lt;/font&gt; &lt;/td&gt; &lt;td align=\"center\"&gt;&lt;font class=\"whiteTitleSmall\"&gt;周二&lt;/font&gt; &lt;/td&gt; &lt;td align=\"center\"&gt;&lt;font class=\"whiteTitleSmall\"&gt;周三&lt;/font&gt; &lt;/td&gt; &lt;td align=\"center\"&gt;&lt;font class=\"whiteTitleSmall\"&gt;周四&lt;/font&gt; &lt;/td&gt; &lt;td align=\"center\"&gt;&lt;font class=\"whiteTitleSmall\"&gt;周五&lt;/font&gt; &lt;/td&gt; &lt;td align=\"center\"&gt;&lt;font class=\"whiteTitleSmall\"&gt;周六&lt;/font&gt; &lt;/td&gt; &lt;td align=\"center\"&gt;&lt;font class=\"whiteTitleSmall\"&gt;周日&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt;&lt;tr&gt; &lt;td bgcolor=\"White\"&gt; &lt;font class=\"blueTitleSmall\"&gt;第1、2节&lt;/font&gt; &lt;/td&gt; &lt;td width=\"14%\" valign=\"top\" bgcolor=\"White\" height=\"80\"&gt; &lt;table height=\"100%\" width=\"100%\" border=\"0\"&gt; &lt;tbody&gt;&lt;tr&gt; &lt;td valign=\"middle\" align=\"center\"&gt; &lt;span class=\"gensmall\"&gt; 现代汉语B&lt;br&gt; 2284&lt;br&gt; 王宇枫 副教授&lt;br&gt; 1-16周 2节&lt;br&gt; 44楼A区105&lt;br&gt; &lt;a href=\"javascript:showCourseInfo(2284)\"&gt;课程信息&lt;/a&gt; - &lt;img src=\"forum/img/icon_mini_search.gif\" alt=\"2016 汉语言文学1班;[选课总人数：38]\"&gt;&lt;br&gt; &lt;/span&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; &lt;/td&gt;&lt;/body&gt;\"\"\"soup = BeautifulSoup(htmil_doc,\"html.parser\",from_encoding='utf-8')print \"获取所有连接\"links = soup.find_all('a')for link in links: print link.name,link['href'],link.get_text()print(links.__dict__) 基本用法就是创建一个beautifulsoup对象，这个对象接受三个参数：1.html_doc下载下来的html文件或者字符串，2对这个字符串的解析方法，这里选择的是’html.parser’方法，3解析这个html的编码，一般情况下是utf-8或者gbk。然后可以使用beautifulsoup中的find()或者find_all()方法来选择我们所需要的数据，这两个方法可以传入某个特定的字符，也可以是一段正则表达式，详情请自行百度。 ######本次只是记录了爬虫最基本的架构和用法，更多详细用法之后会慢慢加上去。","tags":[]},{"title":"贪心算法典型例题记录","date":"2017-03-14T04:20:41.000Z","path":"2017/03/14/贪心算法典型例题记录/","text":"问题描述 在现代的魔术表演中，穿越墙壁是非常受欢迎的，魔术师在一个预先设计好的舞台上表演穿越几面墙壁。在每次穿越墙壁的表演中，穿墙魔术师有一个有限的穿墙能量，通过至多k面墙。墙壁被放置在一个网格状的区域中。右图给出 俯视图。所有的墙的厚度是一个单元，但长度不同。观众选择一列方格，穿墙者从图的上方沿着一列方格向下走，穿过每一面在他路上遇到的墙，到达图的下方。如果他试图走的那一列要穿过的墙超过k面，他将无法完成这个节目。例如右图中，一个穿墙者在k=3的情况下，从上到下可以选择除了第6列以外的任何一列。 给出一个穿墙者的能量以及一个表演舞台，要求在舞台上拆除最少数量的墙，使得表演者可以沿任意观众选择的列穿过所有的墙。输入：输入的第一行给出一个整数t(1≤t≤10)，表示测试用例的个数，然后给出每个测试用例的数据。每个测试用例的第一行给出两个整数n(1≤n≤100，表示墙的面数)和k(1≤k≤100，表示穿墙者可以通过的墙的最大面数)。在这一行后，给出n行，每行包含两个(x, y)对，表示一面墙的两个端点坐标。坐标是小于等于100的非负整数。左上角的方格的坐标为(0, 0)。输出：每个测试用例一行，给出一个整数，表示最少拆除墙的面数，使得穿墙者能从上方任何一列开始穿越。 样例输入23 12 0 4 00 1 1 11 2 2 27 30 0 3 06 1 8 12 3 6 34 4 6 40 5 1 55 6 7 61 7 3 7 思路：先根据输入创建好一个二维数组（即墙的坐标），之后在一列一列的扫描，如果当前列的墙数少于最大可穿数就继续扫描下一列，否则依次拆除从此列开始向右最长的墙直到可以穿过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//// main.cpp// cross_wall//// Created by 吴金东 on 2017/3/11.// Copyright © 2017年 吴金东. All rights reserved.//#include &lt;iostream&gt;using namespace std;int main(int argc, const char * argv[]) &#123; // insert code here... int x,y,x1,y1;//x、y、x1、y1是输入的坐标 int max_x,max_y;//max_x是有墙数的最大列数，max_y是有墙数的最大行数 int sum;//需要拆除的墙数 max_x=0;max_y=0; int map[105][105]; printf(\"请输入测试样例的个数\"); int num;//测试样例的个数 scanf(\"%d\",&amp;num); while (num--) &#123; printf(\"请输入墙数和最大穿墙数\"); sum = 0;memset(map,0,sizeof(map)); int t,k;//t是墙数k是最大穿墙数 scanf(\"%d %d\",&amp;t,&amp;k); for (int i = 1; i&lt;=t; i++) &#123; printf(\"请输入坐标\"); scanf(\"%d %d %d %d\",&amp;x,&amp;y,&amp;x1,&amp;y1);//输入第i面墙的坐标 if (x1 &gt; x &amp;&amp; x1&gt;max_x) &#123; max_x = x1; &#125; if (x &gt; x1 &amp;&amp; x&gt;max_x) &#123; max_x = x; &#125; if (y&gt;max_y) &#123; max_y = y; &#125; if (x&lt;x1) &#123; //标记第i面墙 for (int q = x; q&lt;=x1; q++) &#123; map[q][y] = i; &#125; &#125;else&#123; for (int q = x1; q&lt;=x; q++) &#123; map[q][y] = i;; &#125; &#125; &#125;//for for (int w = 0; w &lt;= max_x; w++) &#123;//从左向右扫描每一列 int temp = 0; for (int m = 0; m&lt;= max_y; m++) &#123;//扫描每一列的墙数 if (map[w][m] != 0) &#123; temp++; &#125; &#125;//for int offset = 0; if (temp &lt;= k) &#123; continue; &#125;else&#123; offset = temp - k; &#125; sum += offset; while (offset) &#123; int max_wall=0;//大于k的列有墙的那一行墙的最大长度 int wall_y = 0; //找出需要拆除的墙所在的行w 列 wall_y int t_y=0; for (int j=0; j&lt;=max_y; j++) &#123; if (map[w][j]&gt;0) &#123; int wall_len = 0; for (int c=w; c&lt;=max_x; c++) &#123;//求墙的长度 if (map[c][j]&gt;0) &#123; wall_len++; t_y = j; &#125;else&#123; wall_len=0; &#125; if (wall_len&gt;max_wall) &#123; max_wall = wall_len; wall_y = t_y; &#125; &#125;//for &#125;else&#123; continue; &#125; &#125;//for找出了需要拆除的最长的墙所在的行w 列 wall_y for (int l = 0; l&lt;max_wall; l++) &#123; map[w+l][wall_y] = 0; &#125; offset--; &#125;//while &#125;//for printf(\"%d\\n\",sum); &#125;//while return 0;&#125;","tags":[]},{"title":"C/C++编译器中“字节对齐”的工作原理","date":"2017-03-14T02:07:19.000Z","path":"2017/03/14/C:C++编译器中“字节对齐”的工作原理/","text":"一 .字节对齐的概念 编译器在编译我们写好的c/c++代码时会根据我们设置的“字节对齐”方式来对我们所定义元素进行多种不同方式的储存。在单字节对齐的条件下声明如下代码：char a; short b;我们知道 char 类型默认是1个字节（8个比特），short类型是两个字节（16比特），在一般的操作系统中默认的一个储存单元是2个字节，所以如果在单字节对齐的条件下，上述代码会被储存为如下形式：（下图所示每一行为一个存储单元） 按2字节的对齐方式进行储存则有如下对齐方式：（每一行代表一个存储单元） 二 .实验步骤及环境 本人的程序编译环境是mac，所用的编译器是xcode，上网查资料发现xcode没有自带的字节对齐选项，只能通过c/c++自带的代码进行字节对齐。下图给出一个结构体分别在1 2 4 8 16字节下在二进制文件中的存储方式。所使用的二进制文件编辑器的vim，使用方式：在命令行中输入 vim -b 文件路径/test.txt。由于结构体是以二进制的形式存储在文件中所以打开文件后将会出现乱码显示如图： 之后输入命令 :%!xxd,将文件转换成16进制后进行查看。以下是如下代码以不同字节存储在文件中的不同体现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc, const char * argv[]) &#123; //计算机组成原理——字节对齐测试 #pragma pack(1) struct test1 &#123; char x1; short x2; float x3; char x4; &#125;; test1 a; FILE *fp; fp = fopen(\"/Users/wujindong/Downloads/test1.txt\", \"wb\"); fwrite(&amp;a,sizeof(a),1,fp); fclose(fp);#pragma pack(2) struct test2 &#123; char x1; short x2; float x3; char x4; &#125;; test2 b; fp = fopen(\"/Users/wujindong/Downloads/test2.txt\", \"wb\"); fwrite(&amp;b,sizeof(b),1,fp); fclose(fp);#pragma pack(4) struct test4 &#123; char x1; short x2; float x3; char x4; &#125;; test4 c; fp = fopen(\"/Users/wujindong/Downloads/test4.txt\", \"wb\"); fwrite(&amp;c,sizeof(c),1,fp); fclose(fp);#pragma pack(8) struct test8 &#123; char x1; short x2; float x3; char x4; &#125;; test8 d; fp = fopen(\"/Users/wujindong/Downloads/test8.txt\", \"wb\"); fwrite(&amp;d,sizeof(d),1,fp); fclose(fp);#pragma pack(16) struct test16 &#123; char x1; short x2; float x3; char x4; &#125;; test16 e; fp = fopen(\"/Users/wujindong/Downloads/test16.txt\", \"wb\"); fwrite(&amp;e,sizeof(e),1,fp); fclose(fp); return 0;&#125; 其产生的文件对应字节如下： 用二进制查看工具结果如下（以下顺序是：1 2 4 8 16字节） 由上述分析及图示可以得知，在1字节存储时，x1与x4被分配到一个储存单元中，x2在一个储存单元中，x3占两个储存单元。在2字节储存中，x1 x4被分配到两个不同的单元中，x2 x3和1字节时一样。 在4字节存储方式时作出如下实验：先删除 char x4 结果 原先12字节的文件变成了8字节， 在删除变量x1发现，文件还是8字节，由此可以的出：原先四个变量为，x1(1字节)，x2(两字节)被存储在一个4字节的存储单元中，x3(4字节)，x4（1字节）被分别存储在一个4字节的存储单元中。同理，8字节和16字节作出如下同样实验得出： 8字节时，删除x1（1字节）文件还是12字节，删除x2（2字节）后文件变为8字节，可知x1和x3被存储在一个4字节空间内。在删除x3（4字节）后 文件变为1字节，说明当只剩下一个变量时，即时选择了字节对齐，编译器也只会保留那个变量当前字节。除此之外只删除变量x3（4字节）会出现如下情景 剩下的x1 x2 x4三个变量只有6字节大小，说明每个变量各自占一个2字节的存储单元。16字时，只删除x1（1字节）出现的情况与8字节相同剩下的文件为8字节，但是删除x3（4字节）后产生的文件为8字节而8进制的时候为6字节 当只剩下一个变量x1时在8字节下产生的文件为1字节，在16字节文件下产生的文件为8字节。 同时在8字节和16字节只剩下x3（4字节时）产生的文件为: 三 .c/c++中设置字节对齐的几种方式 1.使用pragma pack的方式选择字节对齐： 123456789#pragma pack(1) //让编译器对这个结构作1字节对齐struct test&#123;char x1;short x2;float x3;char x4;&#125;;#pragma pack() //取消1字节对齐，恢复为默认4字节对齐 2.使用attribute选项 12345678#define GNUC_PACKED __attribute__((packed))struct PACKED test&#123;char x1;short x2;float x3;char x4;&#125;GNUC_PACKED; 写在最后 虽然这只是一次小小的计组作业，但是却能让我们深刻的体会到字节对齐的概念，并且深入理解内存的存储方式。 文章为作者原创，转载请注明出处。","tags":[]},{"title":"Laravel blade模版引擎学习","date":"2017-03-13T15:49:25.000Z","path":"2017/03/13/Laravel blade模版学习/","text":"[TOC] ##一 .什么是模版引擎？ 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。 ##二 .模版引擎的三个作用 1.变量值的输出（echo） 2.条件判断和循环（if ... else、for、foreach、while） 3.引入或继承其他文件 ##三 .什么是blade引擎？ Blade是Laravel提供的一个非常简单、强大的模板引擎，不同于其他流行的PHP模板引擎，Blade在视图中并不约束你使用PHP原生代码。所有的Blade视图都会被编译成原生PHP代码并缓存起来直到被修改，这意味着对应用的性能而言Blade基本上是零开销。Blade视图文件使用.blade.php文件扩展并存放在resources/views目录下。 代码示意12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Laravel&lt;/title&gt; &lt;link href=\"https://fonts.googleapis.com/css?family=Lato:100\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; body &#123; margin: 0; padding: 0; width: 100%; display: table; font-weight: 100; font-family: 'Lato'; &#125; .container &#123; text-align: center; display: table-cell; vertical-align: middle; &#125; .content &#123; text-align: center; display: inline-block; &#125; .title &#123; font-size: 96px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"title\"&gt;Laravel 5&lt;/div&gt; &lt;?php echo \"welcome\"; ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 这里我们注意到，在上述代码中不仅有html代码还有一句echo \"welcome\"; ?>```这是因为blade引擎默认的文件都是php文件，与普通的html文件不同，我们不仅能在里面写html代码更能编写php代码。除此之外，blade引擎还自带了特殊的关键字：@section、@yield、@extends、@parent等命令。123456789101112131415161718**@section用来标记一个blade模版中的一部分，用@yield让这部分在另一个模版中表示出来。**```html&lt;!-- 存放在 resources/views/layouts/master.blade.php --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;App Name - @yield(&apos;title&apos;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section(&apos;sidebar&apos;) This is the master sidebar. @show &lt;div class=&quot;container&quot;&gt; @yield(&apos;content&apos;) &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; &gt;上述代码表示标记了一个名叫:sidebar的部分用来在之后的地方使用，并且用到了以前标记的 title 和 content这两个部分。 定义子页面的时候，可以使用Blade的@extends指令来指定子页面所继承的布局，继承一个Blade布局的视图将会使用@section指令注入内容到布局的片段中，记住，如上面例子所示，这些片段的内容将会显示在布局中使用@yield的地方： 123456789101112131415&lt;!-- 存放在 resources/views/layouts/child.blade.php --&gt;@extends('layouts.master')@section('title', 'Page Title')@section('sidebar') @parent &lt;p&gt;This is appended to the master sidebar.&lt;/p&gt;@endsection@section('content') &lt;p&gt;This is my body content.&lt;/p&gt;@endsection 使用@parent可以在已经标记好的@section中添加（不是覆盖）新的东西，如上述就在sidebar中加入了一行&lt;p&gt;This is appended to the master sidebar.&lt;/p&gt;代码，并且还会保存之前的东西。 还有其他的相关操作如数据显示、流程控制、服务注入等请参考laravel文档 ##四 模版渲染原理 Laravel 的 View 部分是内置了两套输出系统：直接输出和使用 Blade 引擎“编译”后输出，默认情况下它们通过文件名后缀来选择：.blade.PHP 后缀的认为是模板视图文件，其他的 .php 文件按照 PHP 本身的方式执行。虽然 Blade 模板文件中也可以随意嵌入 PHP 代码，但如果并没有使用，系统还去进行语法解析和替换也是没有必要的，这样可以提高效率。使用 View 组件输出时，不管是调用 helpers 中提供的 view 函数还是使用 Facades 提供静态接口View::make()，实际上执行的都是 Illuminate\\View\\Factory 中的 make 方法。以此为入口，很容易就能知道视图解析输出的流程：查找视图文件；根据文件名后缀从 Container 中取出响应的引擎；加载视图文件或编译后加载编译后的文件执行，同时将需要解析的数据暴露在视图文件环境中。更多详细内容请参考skykingf的博客","tags":[]},{"title":"Hello World","date":"2017-03-13T07:51:01.000Z","path":"2017/03/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]